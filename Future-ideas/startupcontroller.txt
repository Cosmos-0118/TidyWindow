Startup Controller – staged boot experience
-----------------------------------------

Goal
- Reduce boot-time thrash by orchestrating startup applications instead of letting Windows launch everything simultaneously.
- Provide a dedicated UI that inventories all startup entries (registry Run keys, Startup folders, scheduled tasks, services, AppX StartupTasks) and lets the user assign priority, delay, or disablement.

Feasibility & approach
1. **Detection**
	- Use a PowerShell helper to enumerate:
	  • HKCU/HKLM Run + RunOnce
	  • Startup folders (per-user + all users)
	  • Scheduled tasks with `LogonTrigger`
	  • Services with `Auto`/`DelayedAuto` start
	  • AppX packages with StartupTask declarations (`Get-AppxPackage` + manifest parse)
	- Capture metadata: publisher, executable path, command line, startup type, estimated impact (leverage Windows Startup Impact data if available, else compute using our own heuristics).
2. **Controller service**
	- Install a lightweight background service (or scheduled task) launched at boot with highest priority. This service becomes the “gatekeeper” that relaunches user-designated apps according to our schedule after temporarily disabling their native startup triggers.
	- Implementation sketch:
	  • When user applies settings, we disable native startup entries (e.g., move Run key items under a backup key, disable scheduled tasks, set services to Manual).
	  • Our service stores the schedule (JSON) and on boot, re-launches apps sequentially according to priority + delay offsets, optionally re-enabling services.
	- Ensure we can fall back gracefully: include a panic toggle (“Restore default startup behavior”) to revert everything.

UI concept (Startup Controller page)
1. **Overview**
	- Summary cards: “Total startup apps”, “Staggered launches enabled”, “Estimated CPU savings”.
	- Toggle to make TidyWindow launch first (places our scheduler task in Run key/Task Scheduler with highest priority).
2. **Startup list**
	- Table/grid showing every item: name, source (Run key, Service, AppX), impact, last launch time.
	- Users can drag to reorder or assign explicit priority numbers (1,2,3…).
	- Per-item controls: delay slider (0s–300s), disable toggle, “Never manage” toggle (for critical security apps).
3. **Schedules & profiles**
	- Allow saving presets (e.g., “Battery Saver profile”, “Gaming profile”). Switching profile updates the priority/delay set.
	- Provide quick actions: “Launch networking tools first”, “Delay heavy apps by 2 minutes”.
4. **Diagnostics**
	- Timeline showing how long each launch took during last boot based on telemetry from the service.
	- Button to force-run the next startup wave for testing without rebooting.

Safety considerations
- Clearly warn users before disabling entries; offer “Restore defaults” link that re-enables everything in-place.
- Maintain per-entry backups (store original registry/task definitions) so we can restore even if the app is uninstalled.
- Respect protected entries (antivirus, accessibility tools) by default—mark them as “locked” unless user confirms.

Implementation steps
1. Build `automation/scripts/get-startup-footprint.ps1` to emit structured data for the UI.
2. Create `StartupControllerService` (Windows service or scheduled task) that runs at boot, reads schedule, launches apps sequentially, and logs status.
3. Add `StartupControllerViewModel` + `StartupControllerPage.xaml` (multi-pane layout similar to Settings/Automation page).
4. Implement apply/reset logic: disable native entries, store backups, write schedule JSON, register service.
5. Telemetry/logs so users can see what launched, what failed, and how much time each step took.

Stretch goals
- Provide an “Only on AC power” option for heavy apps.
- Sync schedules via cloud export/import.